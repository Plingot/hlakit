{"name":"HLAKit","tagline":"","body":"# Introduction\r\n\r\n[HLAKit](https://github.com/Wookie/hlakit) is a new compiler for a language based on [NESHLA](http://neshla.sourceforge.net/) (NES High Level Assembler) by Brian Provinciano.  The NESHLA compiler is a Windows-only application targeted only at the NES system and has lots of NES-specific features in both the language and the standard library.  I [ported the original NESHLA to Linux](http://bitbucket.org/wookie/neshla) in 2009 with the idea of extending it, but I soon decided it would be better to start from scratch in Python. HLAKit aims to be a compiler for a more general HLA (high level assembly) language targeted at as many old video game consoles and computers as possible.\r\n\r\nThe HLAKit compiler is implemented using the [PLY](http://www.dabeaz.com/ply/) Python module to handle all of the scanning and parsing.  The goal is to structure the compiler in such a way that all platform/CPU specific pieces of the language are modular and swappable.  Currently, the list of platform and/or CPU specific parts includes: assembly opcodes, register names, if/while test values, and preprocessor directives.  These will be explained in more detail later on.\r\n\r\nWhy do this?  An HLA language gives a nice balance between structured programming and assembly language.  It allows you to program using functions, structs, named variables, if-else blocks and loops while still preserving precise, cycle-counted control over the machine.  Unlike C, the HLA understood by the HLAKit compiler uses assembly for the body of functions.  When you are coding for old, 8-bit and 16-bit computers that have precise timing requirements, assembly language is the only way to be sure you are getting the most out of the machine.\r\n\r\n## Quick Start for the Impatient\r\n\r\nThe fastest way to get started with HLAKit is to clone the repo and install it.\r\n\r\n```sh\r\n$ git clone git://github.com/Wookie/hlakit.git\r\n$ cd hlakit\r\n$ sudo python ./setup.py install\r\n```\r\nThat's it.  You'll have to read the rest of the documentation to learn the language and how to use the compiler.\r\n\r\n# The Language\r\n\r\nThe language that the HLAKit compiler understands has many similarities with the C language.  Code blocks and structs are surrounded by curly braces `{ }` and the conditional statements look very similar to what you see in C.  That's where the similarities end though.  The goal of the language is to make writing assembly applications just a tiny bit easier by supporting some of the higher level constructs found in C.  When writing code in the HLAKit language, you will be writing mostly assembly.  But instead of using labels everywhere and hand coding tests and jumps, you can rely on function calls and higher level conditional constructs like `if(set) {} else {}`.\r\n\r\nThroughout this documentation you will see used, the terms \"target\", \"family\", \"platform\", and \"CPU\".  For a lot of old hardware, there is a family of machines with slightly different technical specifications and CPU's.  For instance, the Apple II family of computers has nine different varieties--or platforms.  Some of the platforms came with one of several different CPU's.  The platform specifies the set of peripherals, memory layout, and available CPU's.  In a family of machines, there is a platform for each major, distict combination of peripherals and memory layout.  From the software perspective, if the only thing that changes is the CPU, then a new platform is not warranted.  The Apple IIe originally shipped with a standard 6502 but the later \"enhanced\" version had a 65C02.  Even though the chips on the motherboard changed significantly, along with the CPU, from the software perspective, the two machines are identical except for the CPU change.  Therefore the Apple IIe and the enhanced version are the same platform.\r\n\r\nA \"target\" is the combination of family, platform, and CPU.  In the HLAKit world, the way a target is specified is:  <family>-<platform>-<cpu>.  When the HLAKit compiler runs, it is compiling for a specific target.  Some examples are AppleII-e-65C02, NES-NTSC-2A03, Gameboy-DMG-LR35902, and Gameboy-GBC-LR35902.  One of the things to remember with this language is that many of the preprocessor directives, conditional tests, and assembly opcodes are platform and/or CPU dependent.  So know what target you are writing for.\r\n\r\n## The Preprocessor\r\n\r\nThe HLAKit language supports \"preprocessor\" directives just like a standard C compiler.  However, the \"preprocessor\" in HLAKit is much more flexible and extensible.  It is more accurate to think of the \"preprocessor\" directives as \"immediate mode\" instructions that get executed while the compiler is working.  The C preprocessor is really only useful for conditional compiles and limited macro-based substitution.  The HLAKit preprocessor does all of that but is also extensible for CPU and/or platform extensions.  Things like specifying memory banks, currently address, specifying ROM names, and outputting messages are all things found in the HLAKit preprocessor.\r\n\r\nThe rest of this section covers the preprocessor directives that are always valid, regardless of the CPU or platform specified.\r\n\r\n### Define\r\n\r\nSyntax:\r\n```\r\n#define LABEL [VALUE]\r\n```\r\n\r\nThe `#define` directive is used to both define variables in the preprocessor symbol table, but also to assign values which are used for substitution.  They are included in the language to reduce code duplication and enhance readability.\r\n\r\nExamples:\r\n```\r\n// defining boolean true/false integers\r\n#define TRUE 1\r\n#define FALSE 0\r\n\r\n// defining a string\r\n#define PROGRAM_VERSION \"Version 1.0\"\r\n\r\n// defining a bitmask\r\n#define ST_VBLANK %10000000\r\n\r\n// defining for conditional compile\r\n#define DEBUG_BUILD\r\n```\r\n\r\n### Undef\r\n\r\nSyntax:\r\n```\r\n#undef LABEL\r\n```\r\n\r\nThe `#undef` directive deletes a symbol from the preprocessor symbol table.\r\n\r\nExamples:\r\n```\r\n// undefining previously defined integers\r\n#undef TRUE\r\n#undef FALSE\r\n```\r\n\r\n### Ifdef, Ifndef, Else, and Endif\r\n\r\nSyntax:\r\n```\r\n#ifdef LABEL\r\n#endif\r\n\r\n#ifndef LABEL\r\n#endif\r\n\r\n#ifdef LABEL\r\n#else\r\n#endif\r\n\r\n#ifndef LABLE\r\n#else\r\n#endif\r\n```\r\n\r\nThe conditional directives `#ifdef`, `#ifndef`, `#else`, and `#endif` are used for conditional compilation and execution of other preprocessor directives.  Each conditional block begins with either `#ifdef` or `#ifndef` and ends with either and `#else` or `#endif`.\r\n\r\nExamples:\r\n```\r\n#ifdef DEBUG_MODE\r\n#define PROGRAM_VERSION \"Version 1.0 (Debug)\"\r\n#else\r\n#define PROGRAM_VERSION \"Version 1.0 (Release)\"\r\n#endif\r\n\r\n#ifndef THISHEADER_H\r\n#define THISHEADER_H\r\n// contents of the header\r\n#endif\r\n```\r\n\r\n### Todo, Warning, Error, and Fatal Messages\r\n\r\nSyntax:\r\n```\r\n#todo [QUOTED_STRING]\r\n#warning [QUOTED_STRING]\r\n#error [QUOTED_STRING]\r\n#fatal [QUOTED_STRING]\r\n```\r\n\r\nThe `#todo`, `#warning`, `#error`, and `#fatal` preprocessor directives are used to output messages, of varying intensities, during compile time.  The `#fatal` directive will output its message, if any, and halt compiler execution.\r\n\r\nExamples:\r\n```\r\n#ifdef DEBUG_MODE\r\n#warning \"This will not be executable on actual hardware\"\r\n#endif\r\n\r\n#todo \"Oops, still need to implement this.\"\r\n```\r\n\r\n### Include, Incbin, and Usepath\r\n\r\nSyntax:\r\n```\r\n#include QUOTED_STRING\r\n#incbin QUOTED_STRING\r\n#usepath QUOTED_STRING\r\n```\r\n\r\nThe `#include` and `#incbin` directives tell the compiler to replace the `#include` or `#incbin` line with the contents of the specified file and then continue compiling.  The `#usepath` directive adds a directory to the compiler's list of directories to search for files specified in `#include` and `#incbin` directives.\r\n\r\nExamples:\r\n```\r\n#include \"nes.h\"\r\n#incbin \"sprites.chr\"\r\n```\r\n\r\n## Target Specific Preprocessor Directives\r\n\r\nAs mentioned above, the HLAKit compiler translate the HLAKit language into a target-specific binary.  To do that, there are many parts of the language that change depending on which family, platform, and CPU are specified in the target.  The preprocessor is one of them.  All target-specific preprocessor directives must use the full target prefix: `#<family>.<platform>.<cpu>.<directive>` unless the family, platform, and CPU are either specified on the command line or in the code.  \r\n\r\nThe preprocessor also automatically defines symbols for `__FAMILY__`, `__PLATFORM__`, `__CPU__`, and `__TARGET__`, that contain the family, platform, CPU and target strings respectively.\r\n\r\n### Family, Platform and CPU\r\n\r\nSyntax:\r\n```\r\n#family QUOTED_STRING\r\n#platform QUOTED_STRING\r\n#cpu QUOTED_STRING\r\n```\r\n\r\nInstead of specifying the family, platform, and CPU target on the command line, you may want to use these preprocessor directives to do it in the code.  These allow you to avoid having to type the full `#<family>.<platform>.<cpu>.` prefix for the target-specific preprocessor directives.  These cannot be used to change the target during an execution of the HLAKit compiler.  If the compiler is configured for one target on the command line and it encounters a different target via the `#family`, `#platform`, and `#cpu` directives in the code, it will exit with an error.\r\n\r\nExamples:\r\n```\r\n#family \"NES\"\r\n#platform \"NTSC\"\r\n#cpu \"2A03\"\r\n```\r\n\r\n## Variables and Types\r\n\r\nThe HLAKit language has a base set of types that is supported on all targets, although the size, in bytes, for each variable may change based on the specified target.  HLAKit supports a C-like `struct` construct for complex data types.\r\n\r\n### The Basic Types\r\n\r\nType|Size (bytes)|Range|Description|Notes|\r\n----|------------|-----|-----------|-----|\r\nbyte|1|0 to 255|8-bit unsigned|\r\nchar|1|-128 to 127|8-bit signed|\r\nbool|1|0 to 255|8-bit boolean|Either zero or non-zero\r\nword|2|0 to 65535|16-bit unsigned|16-bit capable CPU's only\r\ndword|4|0 to 4294967295|32-bit unsigned|32-bit capable CPU's only\r\npointer|1/2/4||8/16/32-bit address|Platform and CPU specific\r\nstruct|||Arbitrary complex type|\r\n\r\n### Typedef\r\n\r\nSyntax:\r\n```\r\ntypedef TYPE ALIAS\r\n```\r\n\r\nThe `typedef` keyword works exactly like the C `typedef`.  It creates a type alias.  This is really only useful for reducing how much you type and making code more readable.\r\n\r\nExamples:\r\n```\r\n// standard type alias\r\ntypedef byte BLAH\r\n\r\n// array type alias\r\ntypedef char player_name[16]\r\n\r\n// struct type alias\r\ntypedef struct\r\n{\r\n    byte x\r\n    byte y\r\n} coordinates\r\n```\r\n\r\n","google":"UA-10082522-6","note":"Don't delete this file! It's used internally to help with page regeneration."}