{"name":"HLAKit","tagline":"","body":"# Introduction\r\n\r\n[HLAKit](https://github.com/Wookie/hlakit) is a new compiler for a language based on [NESHLA](http://neshla.sourceforge.net/) (NES High Level Assembler) by Brian Provinciano.  The NESHLA compiler is a Windows-only application targeted only at the NES system and has lots of NES-specific features in both the language and the standard library.  I [ported the original NESHLA to Linux](http://bitbucket.org/wookie/neshla) in 2009 with the idea of extending it, but I soon decided it would be better to start from scratch in Python. HLAKit aims to be a compiler for a more general HLA (high level assembly) language targeted at as many old video game consoles and computers as possible.\r\n\r\nThe HLAKit compiler is implemented using the [PLY](http://www.dabeaz.com/ply/) Python module to handle all of the scanning and parsing.  The goal is to structure the compiler in such a way that all platform/CPU specific pieces of the language are modular and swappable.  Currently, the list of platform and/or CPU specific parts includes: assembly opcodes, register names, if/while test values, and preprocessor directives.  These will be explained in more detail later on.\r\n\r\nWhy do this?  An HLA language gives a nice balance between structured programming and assembly language.  It allows you to program using functions, structs, named variables, if-else blocks and loops while still preserving precise, cycle-counted control over the machine.  Unlike C, the HLA understood by the HLAKit compiler uses assembly for the body of functions.  When you are coding for old, 8-bit and 16-bit computers that have precise timing requirements, assembly language is the only way to be sure you are getting the most out of the machine.\r\n\r\n## Quick Start for the Impatient\r\n\r\nThe fastest way to get started with HLAKit is to clone the repo and install it.\r\n\r\n```sh\r\n$ git clone git://github.com/Wookie/hlakit.git\r\n$ cd hlakit\r\n$ sudo python ./setup.py install\r\n```\r\nThat's it.  You'll have to read the rest of the documentation to learn the language and how to use the compiler.\r\n\r\n# The Language\r\n\r\nThe language that the HLAKit compiler understands has many similarities with the C language.  Code blocks and structs are surrounded by curly braces `{ }` and the conditional statements look very similar to what you see in C.  That's where the similarities end though.  The goal of the language is to make writing assembly applications just a tiny bit easier by supporting some of the higher level constructs found in C.  When writing code in the HLAKit language, you will be writing mostly assembly.  But instead of using labels everywhere and hand coding tests and jumps, you can rely on function calls and higher level conditional constructs like `if(set) {} else {}`.  One of the things to remember with this language is that the preprocessor directives, conditional tests, and assembly opcodes are all CPU and/or platform dependent.  So know your machine.\r\n\r\n## The Preprocessor\r\n\r\nThe HLAKit language supports \"preprocessor\" directives just like a standard C compiler.  However, the \"preprocessor\" in HLAKit is much more flexible and extensible.  It is more accurate to think of the \"preprocessor\" directives as \"immediate mode\" instructions that get executed while the compiler is working.  The C preprocessor is really only useful for conditional compiles and limited macro-based substitution.  The HLAKit preprocessor does all of that but is also extensible for CPU and/or platform extensions.  Things like specifying memory banks, currently address, specifying ROM names, and outputting messages are all things found in the HLAKit preprocessor.\r\n\r\n### The Common Preprocessor Directives\r\n\r\nThis section covers the preprocessor directives that are always valid, regardless of the CPU or platform specified.\r\n\r\n#### `#define`\r\n\r\nSyntax:\r\n```\r\n#define LABEL [VALUE]\r\n```\r\n\r\nThe `#define` directive is used to both define variables in the preprocessor symbol table, but also to assign values which are used for substitution.  They are included in the language to reduce code duplication and enhance readability.\r\n\r\nExamples:\r\n```\r\n// defining boolean true/false integers\r\n#define TRUE 1\r\n#define FALSE 0\r\n\r\n// defining a string\r\n#define PROGRAM_VERSION \"Version 1.0\"\r\n\r\n// defining a bitmask\r\n#define ST_VBLANK %10000000\r\n\r\n// defining for conditional compile\r\n#define DEBUG_BUILD\r\n```\r\n\r\n#### `#undef`\r\n\r\nSyntax:\r\n```\r\n#undef [LABEL]\r\n```\r\n\r\nThe `#undef` directive deletes a symbol from the preprocessor symbol table.\r\n\r\nExamples:\r\n```\r\n// undefining previously defined integers\r\n#undef TRUE\r\n#undef FALSE\r\n```","google":"UA-10082522-6","note":"Don't delete this file! It's used internally to help with page regeneration."}