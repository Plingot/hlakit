---
layout: default
title: HLAKit Language Reference
---

<div class="page-header">
  <h1>Atari - Lynx - MOS65SC02</h1>
</div>

<p>The Atari Lynx target uses the MOS 65SC02 CPU. This has a slightly different set of opcodes than a standard MOS 6502. It also differs from just about every other 6502-based machine in that it cannot directly address the cartridge ROM memory. The Lynx uses a pair of memory mapped read registers that data is read through. To specify the cartridge ROM address, the Lynx uses an address shift register and an address ripple counter. The address shift register stores the 8 most-significant bits of the ROM address (bits 12-19). The address ripple counter stores the 11 least-significant bits of the ROM address (bits 0-10). Bit 11 in the ROM address is not connected to the ROM.</p>
<p>Every Atari Lynx cartridge has 256 blocks of memory. The size of each block varies depending on the cartridge. The address shift register is used to select which block of ROM memory to read from. The address ripple counter addresses a specific byte in the block. The address ripple counter can be set to a specific value and then every subsequent read from the memory-mapped read register will increment the address ripple counter. This allows subsequent reads from the memory-mapped read register to read segments of data from the ROM.</p>
<p>In addition to the address shift register and the address ripple counter, the Atari Lynx has two different memory-mapped read registers. The two different read registers use differen strobe lines and can therefor be used to talk to two different banks of memory. There is also the auxilary data in/out (AUDIN) that can act as an additional address line for custom cartridges.</p>
<p>Not every cart uses all bits of the address ripple counter. Below is a table of possible cartidge configurations.</p>
<table>
<thead>
<tr class="header">
<th align="left">Total Size</th>
<th align="left">Block Count</th>
<th align="left">Block Size</th>
<th align="left">Bits</th>
<th align="left">Banks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">64KB</td>
<td align="left">256</td>
<td align="left">256B</td>
<td align="left">0-7</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">128KB</td>
<td align="left">256</td>
<td align="left">512B</td>
<td align="left">0-8</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">256KB</td>
<td align="left">256</td>
<td align="left">1KB</td>
<td align="left">0-9</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">512KB</td>
<td align="left">256</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">1MB</td>
<td align="left">256</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">2MB</td>
<td align="left">512 (+AUDIN)</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<h2 id="preprocessor">Preprocessor<a class="anchor" href="#Preprocessor" name="Preprocessor"></a></h2>
<h3 id="rom-ram-banks">ROM, RAM, Banks</h3>
<p>Because the Atari Lynx cannot directly address its cartridge ROM, all code compiled for the Atari Lynx has to be linked and located in the 64KB RAM memory area. However, to build a full Lynx ROM file, the compiled executable has to be stored in the ROM memory area. This calls for a two-stage process for building an Atari Lynx game. It also means that branching almost always has to use relative addresses because so that executable data can be loaded into an arbitrary piece of RAM and executed.</p>
<p>The Atari Lynx target initializes several preprocessor variables with the configuration information of the compiler. This includes the variables: <code>__TITLE__</code>, <code>__MANUFACTURER__</code>, <code>__ROTATION__</code>, <code>__BANKS__</code>, <code>__BLOCK_COUNT__</code>, and <code>__BLOCK_SIZE__</code>.</p>
<h4 id="align-number">#align NUMBER</h4>
<p>Forces the current block to be aligned to the specified boundary. The argument given must be a power of two. This is handy for forcing ROM blocks to begin on a cart block boundary.</p>
<h4 id="rom.bank-01">#rom.bank 0|1</h4>
<p>Selects which ROM bank the compiler is building.</p>
<h4 id="rom.org-block-address-max_size">#rom.org BLOCK, ADDRESS[, MAX_SIZE]</h4>
<p>Sets the current ROM address by specifying the block number, the block address and the max size for the next set of compiled data. The max size is really there to check assumptions on how much memory the output is taking. It has no direct relationship to block size or anything.</p>
<h4 id="rom.end">#rom.end</h4>
<p>Ends the current block of output.</p>
<h4 id="rom.blockof-label">#rom.blockof( LABEL )</h4>
<p>The <code>#rom.blockof</code> directive translates to the block ROM block number where the given LABEL is located in the ROM. This is handy for initializing variables with the block number of where data can be found.</p>
<h4 id="ram.org-address-max_size">#ram.org ADDRESS[, MAX_SIZE]</h4>
<p>Sets the current RAM address by specifying the address and optional max size for the next block of compiled data. This is used by the compiler for locating and linking executable code. The max size is there for checking assumptions about the size of the compiled data.</p>
<h4 id="ram.end">#ram.end</h4>
<p>Ends the current block of output.</p>
<h4 id="loader.org-max_size">#loader.org [MAX_SIZE]</h4>
<p>The Atari Lynx hardware expects that every game cart being with an RSA encrypted block of executable code. When the Atari Lynx boots, it reads the encrypted data from the game cart, decrypts it and stores the decrypted executable at $0200 in RAM. After the decryption is done, it jumps to $0200 to execute the code. The <code>#loader.org</code> directive begins a block of data that will be encrypted that the Atari Lynx can decrypt. The optional max size argument</p>
<p>Below is a minimal, encrypted, 1st stage loader. It does the absolute bare minimum to get past the decryption phase. It only initializes a few hardware registers to get the Lynx into a sane state and then reads in 256 bytes of data directly following the encrypted loader on the game cart. After reading the 2nd stage loader into RAM, the 1st stage loader executes the 2nd stage loader.</p>
<h4 id="example-loader">Example Loader:</h4>
<pre><code>// turn off .lnx header output
#lnx.off

byte RCART_0    : $FCB2 // cart read register
byte IODIR      : $FD8A // I/O direction register
byte IODAT      : $FD8B // I/O data register
byte SERCTL     : $FD8C // serial control register
byte MAPCTL     : $FFF9 // memory map control register

#define 2ND_LOADER  $FB00  // location of 2nd stage loader

// locate loader for 0x0200
#ram.org 0x0200

function noreturn micro_loader()
{
    // 1. enable Mikey access
    stz MAPCTL

    // 2. init IODIR, force AUDIN to output
    lda #%00010011
    sta IODIR

    // 3. set ComLynx to open collector
    lda #%00000100
    sta SERCTL

    // 4. power on ROM
    lda #%00001000
    sta IODAT

    // 5. read in the 2nd stage loader
    ldx #0
    do
    {
        lda RCART_0
        sta 2ND_LOADER,x
        inx
    } while(not zero)

    // execute the 2nd stage loader
    jmp 2ND_LOADER
}

#ram.end</code></pre>
<h4 id="loader.end">#loader.end</h4>
<p>The <code>#loader.end</code> directive ends a block of data that will be encrypted using the Atari Lynx encryption scheme.</p>
<p>The above loader example forms the 1st stage of a two stage loader. The 2nd stage loader actually loads meta data for the game executable and the hardware details of the ROM. It then uses that information to load the game executable into RAM at the correct location before executing it.</p>
<p>It is likely that you will want to use a Makefile to first compile the code for your Atari Lynx game and then use a separate file to build the final ROM image. It will take a combination of the following preprocessor directives to specify the correct addressing when doing both stages of the ROM compile.</p>
<h4 id="example-executable">Example Executable:</h4>
<pre><code>// turn off .lnx header output to get raw binary
#lnx.off

// locate the main function at 0x0200 in RAM and
// that it cannot bigger than 0xBE38 bytes.
#ram.org 0x0200, 0xBE38

function noreturn main()
{
    forever
    {
        // the game
    }
}

interrupt irq()
{
}

#ram.end</code></pre>
<p>The above example will compile the <code>main()</code> function to be located at 0x0200 in RAM and output a raw binary file that does not have the standard .lnx ROM file header. If the file was called game.hla, the output file would be called game.bin. We can then use <code>#incbin</code> to include the raw binary into the final ROM file. Building a full Atary Lynx ROM image using the two-stage loading scheme, a game executable and a game database is a bit tricky. Below is a full example.</p>
<h4 id="example-rom">Example ROM:</h4>
<pre><code>// configure the .lnx file header
#lnx.version 1
#lnx.name &quot;Demo Game&quot;
#lnx.manufacturer &quot;Demo Studio&quot;
#lnx.rotation &quot;none&quot;

// specify that we have a 512KB cart
#lnx.banks 1
#lnx.block_count 256
#lnx.block_size 2K

// select bank 0
#rom.bank 0

// 1st stage loader goes in block 0, counter 0
#rom.org 0, 0
  #loader.org 
  #incbin &quot;micro_loader.bin&quot;
  #loader.end
#rom.end

// 2nd stage loader goes in block 0, counter 256
#rom.org
  // align this block on 256 byte boundary
  #align 0x0100
  #incbin &quot;2nd_loader.bin&quot;
#rom.end

// meta data for 2nd stage loader at block 0, counter 512
#rom.org
  // align this block on 256 byte boundary
  #align 0x0100

  // the size of the executable
  byte EXE_SIZE_LO_ADDR         = $80
  byte EXE_SIZE_LO              = #lo(#sizeof(&quot;game.bin&quot;))
  byte EXE_SIZE_HI_ADDR         = $81
  byte EXE_SIZE_HI              = #hi(#sizeof(&quot;game.bin&quot;))

  // where the executable should be loaded
  byte EXE_LOC_LO_ADDR          = $82
  byte EXE_LOC_LO               = #lo($0200)
  byte EXE_LOC_HI_ADDR          = $83
  byte EXE_LOC_HI               = #hi($0200)

  // the cart block where executable starts
  byte EXE_BLOCK_ADDR           = $84
  byte EXE_BLOCK                = #rom.blockof(GAME)

  // the number of 256 byte chunks per block
  byte CHUNKS_PER_BLOCK_ADDR    = $85
  byte CHUNKS_PER_BLOCK         = __BLOCK_SIZE__ &gt;&gt; 8

  // the cart block where asset database is located
  byte DATA_BLOCK_ADDR          = $86
  byte DATA_BLOCK               = #rom.blockof(DATA)

  // the end marker
  byte END_ADDR                 = $00
  byte END                      = $00

#rom.end

// main game executable goes in block 1
#rom.org
  // force block to start on block boundary
  #align __BLOCK_SIZE__
GAME:
  #incbin &quot;game.bin&quot;
#rom.end

// the game asset database goes last
#rom.org
  // force block to start on block boundary
  #align __BLOCK_SIZE__
DATA:
  #incbin &quot;data.bin&quot;
#rom.end</code></pre>
<p>The above example shows how we can use the Atari Lynx specific preprocessor directives to build a final ROM binary with a proper .lnx header. All of the Lynx preprocessor directives are described below.</p>
<h3 id="lnx-header">.LNX Header</h3>
<h4 id="lnx.version-12">#lnx.version 1|2</h4>
<p>Used to specify the version of the .lnx header format. Version 1 is the only version supported by Mednafen and Handy at the moment. There is a prosed version 2 that supports a new cart format that uses both the AUDIN and different cart strobes to expand the cart ROM memory out to 2MB.</p>
<h4 id="lnx.name-quoted_string">#lnx.name QUOTED_STRING</h4>
<p>Used to specify the name of the game in the ROM.</p>
<h4 id="lnx.manufacturer-quoted_string">#lnx.manufacturer QUOTED_STRING</h4>
<p>Used to specify the name of the manufacturer of the ROM.</p>
<h4 id="lnx.rotation-quoted_string">#lnx.rotation QUOTED_STRING</h4>
<p>Specifies if the game is to be played in rotated mode. Valid values are &quot;none&quot;, &quot;left&quot; and &quot;right&quot; rotation.</p>
<h4 id="lnx.banks-12">#lnx.banks 1|2</h4>
<p>Tells HLAKit how many banks this ROM image uses.</p>
<h4 id="lnx.block_count-256512">#lnx.block_count 256|512</h4>
<p>Tells HLAKit how many blocks are in each bank. The standard value is 256, but a cart that uses the AUDIN address line as an extra address line can have 512 blocks.</p>
<h4 id="lnx.block_size-value">#lnx.block_size VALUE</h4>
<p>Specifies the size of each block in the cart. Valid values are 256, 512, 1K, 2K, 4K. The 4K value is only possible if the cart uses different read strobes to read from separate memory chips.</p>
<h4 id="lnx.off">#lnx.off</h4>
<p>Tells the HLAKit compiler to not output a standard .lnx header in the output file. This is usefull for producing raw binary files that will be later included into a ROM image file.</p>
<h2 id="interrupts">Interrupts<a class="anchor" href="#Interrupts" name="Interrupts"></a></h2>
<p>Because the Atari Lynx cannot directly address the cart ROM memory, it only supports the plain <code>interrupt</code> keyword. It is up to the programmer to manually set the interrupt address registers at run time. In practice, only the IRQ interrupt is actually used. The various timers in the device call the IRQ interrupt when they time out.</p>
<h4 id="syntax">Syntax:</h4>
<pre><code>interrupt LABEL()
{
    // interrupt handler body
}</code></pre>
<h4 id="example">Example</h4>
<pre><code>interrupt irq()
{
    // handle timer events
}</code></pre>
<h2 id="conditionals">Conditionals<a class="anchor" href="#Conditionals" name="Conditionals"></a></h2>
<p>The MOS 65SC02 has a 7-bit status register. Some bits in the status register are used for conditional branching. The bits used are: C (carry), Z (zero), V (overflow), N (negative). The target-specific conditional keywords for the Atari Lynx are listed in the table below. The table also lists the status register flag tested and the opcode that will be generated when the HLAKit compiler encounters the associated keyword.</p>
<table>
<thead>
<tr class="header">
<th align="left">Condition</th>
<th align="left">Flag</th>
<th align="left">Opcodes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">plus</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="even">
<td align="left">positive</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="odd">
<td align="left">greater</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="even">
<td align="left">minus</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="odd">
<td align="left">negative</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="even">
<td align="left">less</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="odd">
<td align="left">overflow</td>
<td align="left">V</td>
<td align="left">BVC</td>
</tr>
<tr class="even">
<td align="left">carry</td>
<td align="left">C</td>
<td align="left">BCS</td>
</tr>
<tr class="odd">
<td align="left">nonzero</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">set</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">true</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">equal</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="even">
<td align="left">zero</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="odd">
<td align="left">false</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="even">
<td align="left">unset</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">clear</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
</tbody>
</table>
<h2 id="opcodes">Opcodes<a class="anchor" href="#Opcodes" name="Opcodes"></a></h2>
<p>The Atari Lynx MOS 65SC02 is an improved version of the standard MOS 6502. The table below lists the opcode supported by this target.</p>
<p>Opcode|Address Modes|<br />------|-------------|</p>
