---
layout: default
title: HLAKit Language Reference
---

<div class="page-header">
  <h1>Atari - Lynx - MOS65SC02</h1>
</div>

<p>The Atari Lynx target uses the MOS 65SC02 CPU. This has a slightly different set of opcodes than a standard MOS 6502. It also differs from just about every other 6502-based machine in that it cannot directly address the cartridge ROM memory. The Lynx uses a pair of memory mapped read registers that data is read through. To specify the cartridge ROM address, the Lynx uses an address shift register and an address ripple counter. The address shift register stores the 8 most-significant bits of the ROM address (bits 12-19). The address ripple counter stores the 11 least-significant bits of the ROM address (bits 0-10). Bit 11 in the ROM address is not connected to the ROM.</p>
<p>Every Atari Lynx cartridge has 256 blocks of memory. The size of each block varies depending on the cartridge. The address shift register is used to select which block of ROM memory to read from. The address ripple counter addresses a specific byte in the block. The address ripple counter can be set to a specific value and then every subsequent read from the memory-mapped read register will increment the address ripple counter. This allows subsequent reads from the memory-mapped read register to read segments of data from the ROM.</p>
<p>In addition to the address shift register and the address ripple counter, the Atari Lynx has two different memory-mapped read registers. The two different read registers use differen strobe lines and can therefor be used to talk to two different banks of memory. There is also the auxilary data in/out (AUDIN) that can act as an additional address line for custom cartridges.</p>
<p>Not every cart uses all bits of the address ripple counter. Below is a table of possible cartidge configurations.</p>
<table>
<thead>
<tr class="header">
<th align="left">Total Size</th>
<th align="left">Block Count</th>
<th align="left">Block Size</th>
<th align="left">Bits</th>
<th align="left">Banks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">64KB</td>
<td align="left">256</td>
<td align="left">256B</td>
<td align="left">0-7</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">128KB</td>
<td align="left">256</td>
<td align="left">512B</td>
<td align="left">0-8</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">256KB</td>
<td align="left">256</td>
<td align="left">1KB</td>
<td align="left">0-9</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">512KB</td>
<td align="left">256</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">1MB</td>
<td align="left">256</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">2MB</td>
<td align="left">512 (+AUDIN)</td>
<td align="left">2KB</td>
<td align="left">0-10</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<h2 id="preprocessor">Preprocessor<a class="anchor" href="#Preprocessor" name="Preprocessor"></a></h2>
<h3 id="rom-ram-banks">ROM, RAM, Banks</h3>
<p>Because the Atari Lynx cannot directly address its cartridge ROM, all code compiled for the Atari Lynx has to be linked and located in the 64KB RAM memory area. However, to build a full Lynx ROM file, the compiled executable has to be stored in the ROM memory area. This calls for a two-stage process for building an Atari Lynx game. It also means that branching almost always has to use relative addresses because so that executable data can be loaded into an arbitrary piece of RAM and executed.</p>
<h4 id="rom.bank-01">#rom.bank 0|1</h4>
<p>Selects which ROM bank the compiler is building.</p>
<h4 id="rom.org-block-address-max_size">#rom.org BLOCK, ADDRESS[, MAX_SIZE]</h4>
<p>Sets the current ROM address by specifying the block number, the block address and the max size for the next set of compiled data. The max size is really there to check assumptions on how much memory the output is taking. It has no direct relationship to block size or anything.</p>
<h4 id="rom.end">#rom.end</h4>
<p>Ends the current block of output.</p>
<h4 id="ram.org-address-max_size">#ram.org ADDRESS[, MAX_SIZE]</h4>
<p>Sets the current RAM address by specifying the address and optional max size for the next block of compiled data. This is used by the compiler for locating and linking executable code. The max size is there for checking assumptions about the size of the compiled data.</p>
<h4 id="ram.end">#ram.end</h4>
<p>Ends the current block of output.</p>
<p>It is likely that you will want to use a Makefile to first compile the code for your Atari Lynx game and then use a separate file to build the final ROM image. It will take a combination of the following preprocessor directives to specify the correct addressing when doing both stages of the ROM compile.</p>
<h4 id="example-executable">Example Executable:</h4>
<pre><code>// turn off .lnx header output to get raw binary
#lnx.off

// specify RAM to be from 0x0200 to the start
// of the two video buffers at 0xC038
#ram.org 0x0200, 0xBE38

function noreturn main()
{
    forever
    {
        // the game
    }
}</code></pre>
<p>The above example will compile the <code>main()</code> function to be located at 0x0200 in RAM and output a raw binary file that does not have the standard .lnx ROM file header. If the file was called game.hla, the output file would be called game.bin. We can then use <code>#incbin</code> to include the raw binary into the final ROM file.</p>
<h4 id="example-rom">Example ROM:</h4>
<pre><code>// configure the .lnx file header
#lnx.version 1
#lnx.name &quot;My Game&quot;
#lnx.manufacturer &quot;Me, Myself, and I&quot;
#lnx.rotation &quot;none&quot;

// specify that we have a 512KB cart
#lnx.banks 1
#lnx.block_count 256
#lnx.block_size 2K

// start at bank 0, block 0, counter 0
#rom.bank 0
#rom.org 0,0,2K
#incbin &quot;game.bin&quot;
#rom.end</code></pre>
<p>The above example shows how we can use the Atari Lynx specific preprocessor directives to build a final ROM binary with a proper .lnx header. All of the Lynx preprocessor directives are described below.</p>
<h3 id="lnx-header">.LNX Header</h3>
<h4 id="lnx.version-12">#lnx.version 1|2</h4>
<p>Used to specify the version of the .lnx header format. Version 1 is the only version supported by Mednafen and Handy at the moment. There is a prosed version 2 that supports a new cart format that uses both the AUDIN and different cart strobes to expand the cart ROM memory out to 2MB.</p>
<h4 id="lnx.name-quoted_string">#lnx.name QUOTED_STRING</h4>
<p>Used to specify the name of the game in the ROM.</p>
<h4 id="lnx.manufacturer-quoted_string">#lnx.manufacturer QUOTED_STRING</h4>
<p>Used to specify the name of the manufacturer of the ROM.</p>
<h4 id="lnx.rotation-quoted_string">#lnx.rotation QUOTED_STRING</h4>
<p>Specifies if the game is to be played in rotated mode. Valid values are &quot;none&quot;, &quot;left&quot; and &quot;right&quot; rotation.</p>
<h4 id="lnx.banks-12">#lnx.banks 1|2</h4>
<p>Tells HLAKit how many banks this ROM image uses.</p>
<h4 id="lnx.block_count-256512">#lnx.block_count 256|512</h4>
<p>Tells HLAKit how many blocks are in each bank. The standard value is 256, but a cart that uses the AUDIN address line as an extra address line can have 512 blocks.</p>
<h4 id="lnx.block_size-value">#lnx.block_size VALUE</h4>
<p>Specifies the size of each block in the cart. Valid values are 256, 512, 1K, 2K, 4K. The 4K value is only possible if the cart uses different read strobes to read from separate memory chips.</p>
<h4 id="lnx.off">#lnx.off</h4>
<p>Tells the HLAKit compiler to not output a standard .lnx header in the output file. This is usefull for producing raw binary files that will be later included into a ROM image file.</p>
<h2 id="interrupts">Interrupts<a class="anchor" href="#Interrupts" name="Interrupts"></a></h2>
<p>The Atari Lynx supports the same three MOS 6502 interrupts: reset, NMI, and IRQ. The reset interrupt is also aliased as the &quot;start&quot; interrupt. The target interrupt keywords for declaring an interrupt are <code>reset</code>/<code>start</code>, <code>nmi</code>, and <code>irq</code>.</p>
<h4 id="syntax">Syntax:</h4>
<pre><code>interrupt[.reset|start|nmi|irq] LABEL()
{
    // interrupt handler body
}</code></pre>
<h2 id="conditionals">Conditionals<a class="anchor" href="#Conditionals" name="Conditionals"></a></h2>
<p>The MOS 65SC02 has a 7-bit status register. Some bits in the status register are used for conditional branching. The bits used are: C (carry), Z (zero), V (overflow), N (negative). The target-specific conditional keywords for the Atari Lynx are listed in the table below. The table also lists the status register flag tested and the opcode that will be generated when the HLAKit compiler encounters the associated keyword.</p>
<table>
<thead>
<tr class="header">
<th align="left">Condition</th>
<th align="left">Flag</th>
<th align="left">Opcodes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">plus</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="even">
<td align="left">positive</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="odd">
<td align="left">greater</td>
<td align="left">N</td>
<td align="left">BPL</td>
</tr>
<tr class="even">
<td align="left">minus</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="odd">
<td align="left">negative</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="even">
<td align="left">less</td>
<td align="left">N</td>
<td align="left">BMI</td>
</tr>
<tr class="odd">
<td align="left">overflow</td>
<td align="left">V</td>
<td align="left">BVC</td>
</tr>
<tr class="even">
<td align="left">carry</td>
<td align="left">C</td>
<td align="left">BCS</td>
</tr>
<tr class="odd">
<td align="left">nonzero</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">set</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">true</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">equal</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="even">
<td align="left">zero</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="odd">
<td align="left">false</td>
<td align="left">Z</td>
<td align="left">BEQ</td>
</tr>
<tr class="even">
<td align="left">unset</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="odd">
<td align="left">clear</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">Z</td>
<td align="left">BNE</td>
</tr>
</tbody>
</table>
<h2 id="opcodes">Opcodes<a class="anchor" href="#Opcodes" name="Opcodes"></a></h2>
<p>The Atari Lynx MOS 65SC02 is an improved version of the standard MOS 6502. The table below lists the opcode supported by this target.</p>
<p>Opcode|Address Modes|<br />------|-------------|</p>
